header() ::= <<
from midiutil import MIDIFile
import sys
>>

createmidi(varbpm, vartrack) ::= <<
bpm = <varbpm>
midi = MIDIFile(numTracks=<vartrack>, file_format=1)
midi.addTempo(0,0,bpm)
currtrack = 0
>>

body() ::= <<
def addnotes(notes):
    time = notes[0] #When the sequence will start time wise
    temp = 1 #default instrument
    global currtrack #we want the global scope of this variable


    repeat_times = (int)(notes[len(notes)-1])
    
    for x in range(len(time)):
        initialTime = time[x]
        for _ in range(repeat_times):
            for i in range(0, len(notes[1])):
                try:
                    note = notes[1][i][0] #getting the note
                    duration = notes[1][i][1] #duration of the note
                    toInsert = notes[1][i][3] + initialTime
                    if note \< 0:
                        continue

                except:
                    pass
                
                try: #trying for instrument change
                    instrument = notes[1][i][2] #checking for instrument
                    if(instrument != temp):
                        midi.addProgramChange(currtrack, 0, toInsert, instrument) #changing the current instrument
                        temp = instrument
                except:
                    instrument = temp #it keeps the old instrument
                    pass
                
                midi.addNote(currtrack,0,note,toInsert,duration,100)

                print("Added note {}, with instument {} with a duration of {} on time {}, on channel {}".format(note, instrument, duration, toInsert, currtrack))
        currtrack += 1

def getInt(varstr):
    while True:
        try:
            a = int(input(varstr))
        except ValueError:
            print("Please input a valid number")
            continue
        else:
            break
    return a

def duration(toCheck):
    if type(toCheck[0]) is tuple:
        size = len(toCheck)-1
        return toCheck[0][3] + toCheck[size][3] + toCheck[size][1]
    else:
        size = len(toCheck[1]) - 1
        return toCheck[1][0][3] + toCheck[1][size][3] + toCheck[1][size][1]

def modPitch(toMod, ModNumber):
    modded = []
    if type(toMod[0]) is tuple:
        for tup in toMod:
            newPitch = tup[0] + ModNumber
            try:
                if newPitch \< 0:
                    raise ValueError
            except ValueError:
                print("Modulated note below 0, expect silence")
                pass
            newtup = (newPitch, tup[1],tup[2],tup[3])
            modded.append(newtup)
        return modded
    else:
        for tup in toMod[1]:
            newPitch = tup[0] + ModNumber
            try:
                if newPitch \< 0:
                    raise ValueError
            except ValueError:
                print("Modulated note below 0, expect silence")
                pass
            newtup = (newPitch, tup[1],tup[2],tup[3])
            modded.append(newtup)
        toMod[1] = modded
        return toMod


def modTempo(toMod, ModNumber):
    modded = []
    if type(toMod[0]) is tuple:
        for tup in toMod:
            newTempo = tup[1] * ModNumber
            newtup = (tup[0], newTempo,tup[2],tup[3])
            modded.append(newtup)
        return modded
    else:
        for tup in toMod[1]:
            newTempo = tup[1] * ModNumber
            newtup = (tup[0], newTempo,tup[2],tup[3])
            modded.append(newtup)
        toMod[1] = modded
        return toMod

def extendseq(original, toextend):
    modded = []
    if len(original) == 0:
        for tup in toextend:
            newtup = (tup[0], tup[1], tup[2], 0)
            modded.append(newtup)
        return modded
    else:
        for tup in original:
            modded.append(tup)
        time = duration(original)
        for tup in toextend:
            newtup = (tup[0], tup[1], tup[2], time)
            modded.append(newtup)
        return modded

def createseq(seq):
    newseq = []
    for s in seq:
        newseq = extendseq(newseq, s)
    return newseq

def setinstrument(seq,nome):
    if len(seq)==0:
        return seq
    newseq = []
    for tup in seq:
        new = (tup[0],tup[1],nome[tup[0]],tup[3])
        newseq.append(new)
    return newseq

def playPerformace(perf):
    global longest #we want the global scope of this variable
    perf_duration = max(perf[0])+duration(perf[1]) * perf[3]
    if perf_duration > longest:
        longest = perf_duration
    addnotes(perf)

def loop(seq)
    global longest #we want the global scope of this variable
    repeats = longest/duration(seq[1])
    seq[2]=repeats
    return seq

>>

exportfile(name) ::= <<
with open("<name>", 'wb') as file:
    midi.writeFile(file) #Writting the file
    print("MIDI File Written")
>>


vardec(indentation, varname, value) ::= <<
<indentation><varname> = <value>
>>

range(indentation, varname, first, last) ::= <<
<indentation><varname> = range(<first>, <last>+1)
>>

u_addnotes(indentation, varname) ::= <<
<indentation>addnotes(<varname>)
>>

u_getint(indentation, varname, str) ::= <<
<indentation><varname> = getInt(<str>)
>>

u_duration(indentation, varname, performance) ::= <<
<indentation><varname> = duration(<performance>)
>>

u_extendseq(indentation, varname, original, toextend) ::= <<
<indentation><varname> = extendseq(<original>, <toextend>)
>>
u_createseq(indentation, varname, seqs) ::= <<
<indentation><varname> = createseq(<seqs>)
>>

u_modPitch(indentation, varname, performance, modnumber) ::= <<
<indentation><varname> = modPitch(<performance>, <modnumber>)
>>

u_modTempo(indentation, varname, performance, modnumber) ::= <<
<indentation><varname> = modTempo(<performance>, <modnumber>)
>>

u_setinstrument(indentation, varname, seq, instrument) ::= <<
<indentation><varname> = setinstrument(<seq>, <instrument>)
>>

u_playerPerfomace(perf) ::= <<
playPerformace(<perf>)
>>

u_loop(varname,seq) ::= <<
<varname> = loop(<seq>)
>>

forloop(indentation, instance, array) ::= <<
<indentation>for <instance> in <array>:
>>

fornumbers(indentation, first, last) ::= <<
<indentation>for i in range(<first>, <last>+1):
>>

if(indentation, condition) ::= <<
<indentation>if <condition>:
>>

elif(indentation, condition) ::= <<
<indentation>elif <condition>:
>>

else(indentation, code) ::= <<
<indentation>else:
>>


